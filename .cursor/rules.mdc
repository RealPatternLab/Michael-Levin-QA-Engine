---
description: 
globs: 
alwaysApply: false
---
# Michael Levin QA Engine - Development Rules

## ðŸŽ¯ **Core Principles**

### **KEEP IT SIMPLE**
- **One script per workflow**: No complex abstractions or interfaces
- **Minimal dependencies**: Only add what's absolutely necessary
- **Clear file structure**: `inputs/`, `outputs/`, `scripts/`, `configs/`
- **Single responsibility**: Each function does ONE thing well

### **WRITE IN PYTHON**
- Use Python 3.11+ features
- Type hints for all functions
- Clear docstrings
- Follow PEP 8 style guide

### **USE UV FOR ENVIRONMENT CONTROL**
- **Always use `uv` for dependency management**: No pip, no conda, no poetry
- **Install dependencies**: `uv sync` or `uv add package_name`
- **Run scripts**: `uv run python scripts/script_name.py`
- **Install test dependencies**: `uv sync --extra test`
- **Run tests**: `uv run pytest`
- **Create virtual environments**: `uv` handles this automatically
- **Lock dependencies**: `uv lock` to generate lockfile

### **TEST EVERYTHING WITH PYTEST**
- **Every workflow needs tests**: If it's worth writing, it's worth testing
- **Test coverage > 90%**: Aim for comprehensive coverage
- **Test both success and failure cases**: Edge cases matter
- **Mock external APIs**: Don't hit real APIs in tests
- **Fast test execution**: Tests should run quickly

## ðŸ“ **Project Structure Rules**

```
levin-qa-engine/
â”œâ”€â”€ inputs/raw_papers/        # PDFs go here
â”œâ”€â”€ outputs/                  # Results go here
â”œâ”€â”€ scripts/                  # Main workflow scripts
â”œâ”€â”€ configs/                  # Configuration files
â”œâ”€â”€ tests/                    # pytest test files
â”œâ”€â”€ .env                      # Environment variables
â””â”€â”€ README.md                 # Clear documentation
```

## ðŸ§ª **Testing Requirements**

### **For Every New Script:**
1. **Create corresponding test file**: `tests/test_script_name.py`
2. **Test all functions**: Every function needs at least one test
3. **Test error handling**: What happens when things go wrong?
4. **Test edge cases**: Empty files, malformed data, missing APIs
5. **Mock external services**: OpenAI, Google Document AI, file system

### **Test Structure:**
```python
# tests/test_simple_pipeline.py
import pytest
from unittest.mock import Mock, patch
from scripts.simple_pipeline import extract_metadata_with_openai

def test_extract_metadata_with_openai_success():
    """Test successful metadata extraction"""
    with patch('openai.OpenAI') as mock_openai:
        # Setup mock response
        mock_response = Mock()
        mock_response.choices[0].message.content = '{"title": "Test Paper"}'
        mock_openai.return_value.chat.completions.create.return_value = mock_response
        
        result = extract_metadata_with_openai("test text", "test.pdf")
        assert result["title"] == "Test Paper"

def test_extract_metadata_with_openai_failure():
    """Test metadata extraction failure"""
    with patch('openai.OpenAI') as mock_openai:
        mock_openai.side_effect = Exception("API Error")
        
        result = extract_metadata_with_openai("test text", "test.pdf")
        assert result is None
```

## ðŸš« **What NOT to Do**

### **Avoid Complexity:**
- âŒ **No abstract classes or interfaces** unless absolutely necessary
- âŒ **No complex dependency injection**
- âŒ **No microservices or distributed architecture**
- âŒ **No over-engineering for "future-proofing"**
- âŒ **No premature optimization**

### **Avoid Testing Anti-Patterns:**
- âŒ **No tests that depend on real APIs**
- âŒ **No slow tests (>1 second per test)**
- âŒ **No tests that don't actually test anything**
- âŒ **No tests without assertions**

### **Avoid Environment Anti-Patterns:**
- âŒ **No pip install** - use `uv add` instead
- âŒ **No conda environments** - use `uv` virtual environments
- âŒ **No poetry** - use `uv` for dependency management
- âŒ **No manual virtual environment creation** - `uv` handles this
- âŒ **No requirements.txt** - use `pyproject.toml` with `uv`

## âœ… **What TO Do**

### **Keep It Clean:**
- âœ… **Single script per workflow**
- âœ… **Clear function names and docstrings**
- âœ… **Simple configuration in `configs/settings.py`**
- âœ… **Consistent error handling**
- âœ… **Good logging for debugging**

### **Write Good Tests:**
- âœ… **Test the happy path**
- âœ… **Test error conditions**
- âœ… **Mock external dependencies**
- âœ… **Use fixtures for common setup**
- âœ… **Test edge cases**

### **Use UV Properly:**
- âœ… **Install dependencies**: `uv sync`
- âœ… **Add new packages**: `uv add package_name`
- âœ… **Run scripts**: `uv run python scripts/script_name.py`
- âœ… **Run tests**: `uv run pytest`
- âœ… **Install test dependencies**: `uv sync --extra test`
- âœ… **Update dependencies**: `uv lock`

## ðŸƒâ€â™‚ï¸ **Running Tests**

```bash
# Install test dependencies
uv sync --extra test

# Run all tests
uv run pytest

# Run with coverage
uv run pytest --cov=scripts --cov-report=html

# Run specific test file
uv run pytest tests/test_simple_pipeline.py

# Run tests in parallel
uv run pytest -n auto
```

## ðŸ“ **Code Quality Checklist**

Before committing any code:

- [ ] **Does it solve the actual problem?** (Not a theoretical one)
- [ ] **Is it the simplest solution?** (No over-engineering)
- [ ] **Are there tests for it?** (Every function tested)
- [ ] **Does it follow the file structure?** (inputs/outputs/scripts/configs)
- [ ] **Is it documented?** (Clear docstrings and README updates)
- [ ] **Does it handle errors gracefully?** (No unhandled exceptions)
- [ ] **Are dependencies managed with uv?** (No pip/conda/poetry)

## ðŸŽ¯ **Success Metrics**

- **Code simplicity**: Can a new developer understand it in 5 minutes?
- **Test coverage**: >90% coverage on all scripts
- **Fast execution**: Tests run in <30 seconds total
- **Reliable**: No flaky tests or race conditions
- **Maintainable**: Easy to modify and extend
- **Environment consistency**: All developers use `uv` for dependencies

## ðŸš€ **Remember**

**This is a research tool, not a production system.** Keep it simple, test it well, and make it easy to iterate on. The goal is to process papers quickly and reliably, not to build the most sophisticated architecture.

**When in doubt, choose the simpler option.**

**Always use `uv` for Python environment management.**
